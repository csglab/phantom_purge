---
title: "Phantom Purge: Simulating data"
#subtitle: "Empirical Data: analyze"
author: 
- name: Rick Farouni
  affiliation:
  - &cruk Department of Human Genetics, McGill University,  Montreal, Canada
date: '`r format(Sys.Date(), "%Y-%B-%d")`'
output:
  html_notebook:
    df_print: paged
    code_folding: show
    toc: yes
    toc_float: 
      collapsed: false
      smooth_scroll: false
---



# Preparations

```{r}
library(tidyverse)
library(poibin)
library(combinat)
library(furrr)
library(tictoc)
library(data.table)
library(matrixStats)

```


```{r setup}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(future.globals.maxSize= +Inf)

```



```{r}
figures_dir <- file.path("./figures")
```



```{r}
get_product_logsum <- function(x, y) {
  z_log <- log(x) + log(y)
  z <- exp(z_log)
  return(z)
}

create_outcome_variable <- function(outcomes, S) {
  setDT(outcomes)
  
  outcomes[,
       outcome := do.call(paste, c(.SD, sep = ":")),
       .SDcols = 2:(S+1)]
  
  outcomes[order(outcome)]
  
  return(outcomes)
  
}

create_grouping_vars <- function(data, min_frac=0.8) {
  
  
  S <- dim(data)[2] -1
  
  s <- data %>% pull(s) %>% as.numeric()
  
    data <-
    data %>%
    select(c(paste0("y", 1:S))) %>%
    as.matrix()
  
  y_s <- as.integer(data[cbind(seq_along(s), s)] != 0)
  
  
  k_chimera <- as.integer(S - rowCounts(data, value = 0))
  f <- k_chimera -y_s

  r <- as.integer(rowSums2(data))
  
  s_frac <-
    apply(cbind(data,r),
          1,
          function(x) {
            y <- which(x[1:S] >=  (x[S + 1] * min_frac))
            y <- unname(y)
            if (length(y) == 0)
              y <- 0
            return(y)
          })
  
  grouping_vars <- tibble(k_chimera=k_chimera,
                          f = f,
                           s_frac=s_frac)
                          
                          
  return(grouping_vars)
}

infer_sample_of_origin_outcome <- function(..., log_pi_r, log_zi) {
  y <- c(...) #[1:S]
  #sample_pi <- c(...)[(S + 1):(2 * S)]

  #log_zi <- c(...)[2*S+1]
  #zi_vec <- rep(zi, S)
  #posterior_s <- zi_vec ^ y
  posterior_s <- y * log_zi + log_pi_r
  
  ## normalize to the sample with maximum posterior probability
  posterior_s <- posterior_s - max(posterior_s)
  posterior_s <- exp(posterior_s)
  ##
  posterior <- posterior_s / sum(posterior_s)
  q <- max(posterior)
  s_hat <- which.max(posterior)
  # p_mult_vec <- rep(0,S)
  # for(i in 1:S) {
  #   pvec <- rep((1 - phat) / (S - 1), S)
  #   pvec[i] <- phat
  #   p_mult_vec[i] <- exp(log(combinat::dmnom(y,prob=pvec))+log_sample_pi[i])
  # }
  #
  # marg_p <- sum(unlist(p_mult_vec))
  posterior <- as.list(c(posterior, s_hat, q ))
  names(posterior) <- c(paste0("p_s", 1:length(y)),"s_hat", "q")
  return(posterior)
}


generate_outcomes_s <- function(s, p, S, r, pi_r){
  p_h <- (1 - p) / (S - 1)
  pvec <- rep(p_h, S)
  pvec[s] <- p
  pi_r_s <- pi_r[s]

  outcomes <- xsimplex(S, r)
  
  pmf <- apply(outcomes,
               2,
               dmnom,
               prob = pvec)
  
  outcomes <- outcomes  %>% 
                t() %>%
                as_tibble( .name_repair = "unique") %>%
    setNames(paste0("y", 1:S)) %>%
    mutate(pmf_r=pmf*pi_r_s)
  
   

  
 return(outcomes)
}

add_group_variables <- function(outcomes) {
  
  outcomes <- create_outcome_variable(outcomes, S)
  
  grouping_vars <-
    create_grouping_vars(outcomes %>%
                           select(c(paste0("y", 1:S), "s")),
                         min_frac = 0.8)
  
  outcomes <-
    bind_cols(outcomes, grouping_vars)  %>%
    arrange(outcome)
  
  return(outcomes)
}

add_posterior_prob <- function(outcomes, S, p, pi_r) {
  log_zi <- log((S - 1)) - log(1 / p - 1)
  
  posteriors <-
    future_pmap_dfr(
      outcomes %>%
        select(paste0("y", 1:S)),
      infer_sample_of_origin_outcome,
      log_pi_r = log(pi_r),
      log_zi = log_zi
    )
  
  
  outcomes <- bind_cols(outcomes %>%
                          select(-c(paste0("y", 1:S))),
                        posteriors)
  
  return(outcomes)
  
}

compute_classification_metrics <- function(outcomes) {
      eps <- .Machine$double.eps


outcomes <- 
      outcomes%>%   
      arrange(desc(q)) %>%
    mutate(
     # q= q* (q >0.84),
      o = cumsum(pmf_r),
      u = cumsum(get_product_logsum(f, pmf_r)),
      t=  cumsum(get_product_logsum(k_chimera-f, pmf_r)),
      k = cumsum(get_product_logsum(k_chimera ,pmf_r)),
      # pcum_phantom = cumsum(get_product_logsum((k_chimera - 1) * q +
      #                                            (k_chimera) * (1 - q),
      #                                          p_outcome_m
      # )),
      #pcum_phantom = last(pcum_phantom) - pcum_phantom,
      TP = cumsum(get_product_logsum(q, pmf_r)),
      #TP = last(TP) - TP ,
      FP= o-TP,
      #FP = cumsum(get_product_logsum(1 - q, pmf_r)),
     # FP = last(FP)  - FP ,
      TN = last(u)-FP,
      TN = if_else(TN >eps,TN ,0),
      FN= last(t)-TP,
      FN = if_else(FN >eps,FN ,0),
     qs = rev(-10 * log10(1- q +1e-16)),
     FPR = FP / (last(u) ),
     FNR = FN / last(t) ,
     j = 1 - (FPR + FNR),
     j= if_else(j>eps,j,0)
     ) %>%
      select(outcome, pmf_r, s, s_hat, s_frac,  q, o,t, u, k, FP,TP, FN, TN,  everything())
    
    nrow_thresh <- 
      outcomes %>% 
      summarize(nrow_thresh= which(j==max(j))) %>%
      pull(nrow_thresh)
    
   # outcomes <- 
   #   outcomes %>%   
   # mutate(s_hat= s_hat*(nrow_thresh >= 1:n()))
    return(outcomes)
}

```






```{r}
generate_outcomes <- function(p, S, r, pi_r){

    
     outcomes <- future_invoke_map_dfr(rep("generate_outcomes_s", S),
                                       1:S ,
                          p=p,
                          S=S,
                          r=r,
                          pi_r=pi_r,
                          .id = "s")
     
     
    outcomes <- add_group_variables(outcomes)
    
    outcomes <- add_posterior_prob(outcomes, S, p, pi_r) 
    
    outcomes <- compute_classification_metrics(outcomes) 


    
  return(outcomes)
}

simulate_pi_r <- function(S, r_max){
  
  lamdas <- (r_max*5)/1:S
  
  get_rpois_sort <- function(lambda,n){
    x <- rpois(n,lambda) +1
    return(x)
  }
  
  pi_r <-
    map_dfc(lamdas, get_rpois_sort, n=r_max) %>%
    mutate(r=rowSums(.[])) %>%
    mutate_all(list(~(./r)))%>%
    mutate(r=1:r_max)%>%
    select(r, everything()) %>%
    setNames(c("r", paste0("pi_", 1:S)) )

 return(pi_r)
}

simulate_m <- function(r_max, pr =0.2){
  
  N <- seq(1, r_max)
  
  M_log <- log(pr) + (N-1)*log((1-pr))
  
  M_log <- M_log - max(M_log)
  M <- exp(M_log)
  
  M <- M/ sum(M)
  
  M_dt <- tibble( r= N,
                m= M)

 return(M_dt)
}


compute_g <- function(..., p, S){
  
  x <-c(...)
  r <- x[1]
  pi_r <- x[2:(S+1)]
    
  outcomes <- future_invoke_map_dfr(rep("generate_outcomes_s", S),
                                       1:S ,
                          p=p,
                          S=S,
                          r=r,
                          pi_r=pi_r,
                          .id = "s")
    outcomes <- add_posterior_prob(outcomes, S, p, pi_r) 
           
    g <- 
      outcomes%>%   
    mutate( mispredict= s!=s_hat) %>% 
      group_by(mispredict)%>% 
      summarize(pmf_r=sum(pmf_r))%>%
      filter(mispredict==TRUE) %>%
      pull(pmf_r)
    
    return(list(g=g))

}

compute_g_all <- function(pi_r_dt, p, m){
  
 S <- dim(pi_r_dt)[2] -1 
  
 g_dt <- future_pmap_dfr(pi_r_dt,
                          p=p,
                          S=S,
                         compute_g,
                         .id="r")
 g <- 
   g_dt %>% 
   mutate(m=m) %>%
   summarize(g=sum(g*m)) %>%
   pull(g)
 
 return (g)
 
  
}
```

```{r}
p <- 0.90
S <-5
r <-3
alpha <- 1000
#pi_r <- gtools::rdirichlet(1, c(6,3,1)*alpha) 
pi_r <- c(3,9,6,1,7)
#pi_r <- c(6,3,1)
pi_r <- pi_r/sum(pi_r)
pi_r
```

```{r}
phat <- p
y <- c(0,0,0,3,0)
log_sample_pi <- log(pi_r )
   p_mult_vec <- rep(0,S)
   for(i in 1:S) {
    pvec <- rep((1 - phat) / (S - 1), S)
     pvec[i] <- phat
     p_mult_vec[i] <- exp(log(combinat::dmnom(y,prob=pvec))+log_sample_pi[i])
   }
  
  marg_p <- sum(unlist(p_mult_vec))
  marg_p
```

```{r message=FALSE, warning=FALSE}
outcomes <- generate_outcomes(p, S, r, pi_r)
outcomes
```





```{r}
    g <- 
      outcomes%>%   
    mutate( k_chimera_n= k_chimera-1,
            g= f- k_chimera_n)  %>%
    summarize(pmf_g=sum(g*pmf_r))%>%
      pull(pmf_g)

g
```

```{r}
outcomes %>%
  group_by(outcome)%>%
    summarize(pmf_r=sum(pmf_r))
```


```{r}
r_max <-20
pi_r_dt <-simulate_pi_r(S, r_max)
pi_r_dt
```



```{r message=FALSE, warning=FALSE}
m_dt <- simulate_m(r_max, pr=.2 )
m_dt 
```



```{r message=FALSE, warning=FALSE}
compute_g_all(pi_r_dt, p, m_dt$m)
```






```{r}
mispredict= s!=s_hat) %>% 
      group_by(mispredict)%>% 
      summarize(pmf_r=sum(pmf_r))%>%
      filter(mispredict==TRUE) %>%
      pull(pmf_r)
```

```{r}
ggplot(outcomes) +
    geom_point(aes(qs,
                   o),
               size = 1) +
    #   geom_line(aes(qs,
    #               u,
    #               colour = "u")) +
    # geom_line(aes(qs,
    #               t,
    #               colour = "t")) +
    geom_line(aes(qs,
                  TP,
                  colour = "TP")) +
    geom_line(aes(qs,
                  TN,
                  colour = "TN")) +
      geom_line(aes(qs,
                  FN,
                  colour = "FN")) +
        geom_line(aes(qs,
                  FP,
                  colour = "FP")) +
    theme_bw() + 
  labs(x = "qs",
                      y = "proportion") +
    scale_color_manual(
      name = "",
      values = c("red",
                 "darkgrey",
                 "blue",
                 "coral",
                 "orange",
                 "brown")
    ) 
```

```{r}
 outcomes <- 
  outcomes %>% 
  select(-k_chimera,-s_frac) %>%
  select(outcome,  everything(), pmf_r, f) %>%
  arrange(desc(outcome), s)
```


```{r}
 outcomes
```



```{r}
 outcomes %>% dplyr::summarize(ef=sum(pmf_r*f))
```
0.1
```{r}
library(Hmisc)
```
```{r}
latex( outcomes,rowname=NULL ,booktabs=TRUE, file="")
```

```{r}
      pi_r_hat <- 
      outcomes%>%  
          summarize_at(vars(starts_with("p_s")), list(~ sum(.*pmf_r)))    
        

      # 
      #   outcomes_s <- 
      # outcomes %>%
      #  group_by(s)%>%
      #  summarize(pmf_r=sum(pmf_r))
      # 
      #       outcomes_r <- 
      # outcomes %>%
      # select(-s,- pmf_rs,- outcome)%>%
      #  summarize_at(vars(starts_with("y")), list(~ sum(.*pmf_r)))
            data_outcome <- 
      outcomes %>%
      select(-s,- pmf_rs)%>%
       group_by(outcome)%>%
       summarize(pmf_r=sum(pmf_r)) %>%
    separate(
      outcome,
      into = paste0("y", 1:S),
      sep = ":",
      remove = FALSE,
      convert = TRUE
    )
compute_classification_metrics <- function(data_outcome, g) {
  data_outcome <-
    data_outcome %>%
    arrange(q) %>%
    mutate(
      #marg_p_outcome =get_product_logsum(p_outcome,nn_prop),
      # cum_p=cumsum(marg_p_outcome),
      o = cumsum(p_outcome_m),
      FP = cumsum(get_product_logsum(1 - q,
                                     p_outcome_m)),
      FP = last(FP) - FP ,
      FN = FP + o - g,
      pcum_phantom = cumsum(get_product_logsum(k_chimera - 1,
                                               p_outcome_m)),
      # pcum_phantom = cumsum(get_product_logsum((k_chimera - 1) * q +
      #                                            (k_chimera) * (1 - q),
      #                                          p_outcome_m
      # )),
      pcum_reads = cumsum(r * n) / sum(r * n),
      #pcum_phantom = last(pcum_phantom) - pcum_phantom,
      
      qs = -10 * log10((1 - q) + 1e-16),
      FPR = FP / (last(pcum_phantom) + g),
      FNR = FN / (1 - g),
      j = 1 - (FPR + FNR)
    ) %>%
    select(-matches(".ct|.pi$"))
  
  return(data_outcome)
  
}

infer_sample_of_origin <-
  function(data_outcome,
           pi_r_hat,
           phat,
           S,
           g) {
    data_outcome <-
      left_join(
        data_outcome,
        pi_r_hat,
        by = c("r"),
        suffix = c(".ct", ".pi")
      )
    
    
    #zi <- ((S - 1) / (1 / p - 1))
    
    log_zi <- log((S - 1)) - log(1 / phat - 1)
    
    
    
    posteriors <-
      future_pmap_dfr(
        data_outcome %>%
          select(matches(".ct|.pi$")),
        log_zi = log_zi,
        S = S,
        infer_sample_of_origin_outcome
      )
    
    data_outcome <- bind_cols(data_outcome, posteriors)

    data_outcome <- compute_classification_metrics(data_outcome, g)
    
    return(data_outcome)
    
  }





get_posterior_sample <- function(y, p, pi=NULL) {
  S <- length(y)
  
  if (is.null(pi)){
    pi <- rep(1/S, S)
  }
  
  #zi <- ((S - 1) / (1 / p - 1))
  log_zi <- log( (S - 1) ) - log( 1/p - 1 )
  
  #zi_vec <- rep(zi, S)
  #posterior_s <- zi_vec ^ y
  posterior_s <- y * log_zi + log(pi)
  
  ## normalize to the sample with maximum posterior probability
  posterior_s <- posterior_s - max(posterior_s)
  posterior_s <- exp(posterior_s)
  ##
  
  posterior <- posterior_s / sum(posterior_s)
  return(posterior)
}

compute_exact_probs <- function(N, S, p, pi=NULL) {
  
#  start.time <- Sys.time()
  p_h <- (1 - p) / (S - 1)
  pvec <- rep(p_h, S)
  pvec[1] <- p

  simplex_mtx <- xsimplex(S, N)
  
  pmf <- apply(simplex_mtx,
               2,
               dmnom,
               prob = pvec)
  
  posteriors <- apply(simplex_mtx,
                    2,
                    get_posterior_sample,
                    p = p,
                    pi=pi)

  
 max_p <- apply(posteriors,
                    2,
                    max)

simplex_mtx <- simplex_mtx  %>% 
                t() %>%
                as_data_frame() %>%
    setNames(paste0("y", 1:S))
 
  posteriors <- posteriors %>%
    t() %>%
    as_data_frame()  %>%
    setNames(paste0("p", 1:S)) %>%
    bind_cols(simplex_mtx, 
              .)  %>%
    mutate(
      max_p= !!max_p,
      k_chimera  = as.integer(rowSums(.[1:S] != 0)),
      n_phantoms = as.integer(rowSums(.[2:S] != 0)),
      n_hopreads = as.integer(rowSums(.[2:S])),
      pmf = pmf) %>% 
   select(-matches("^[p][0-9]"))  %>%
    mutate_at(vars(1:S), funs(m=as.integer(. != 0))) %>%
    unite(chimera,
          ends_with("_m"),
          sep = '')%>%
    unite(outcome,
          starts_with("y"),
          sep = ':')%>%   
    mutate(rpattern = outcome %>% 
  map(str_split_fixed, pattern=":",n=S) %>%
   map(str_sort, numeric = TRUE, decreasing = TRUE) %>%
   map(str_c, collapse =":")  %>% 
   unlist(),
  score= -10*log10((1-max_p) +1e-16))%>%    
    arrange(score)
  
  #%>% 
    #mutate(pcum_misassign=cumsum(p_misassign))

 # end.time <- Sys.time()
 # message(paste0("time for ", N, "-", S, "-", p, ":"),  end.time  - start.time)
 # list(exact_probs=exact_probs,exact_probs_collapsed=exact_probs_collapsed)
  return(posteriors)
}


compute_exact_probs_N <- function(N_max, S, p){
  N <- 1:N_max
  combin <-  cross3(N, S, p) %>%
    map(setNames, c("N", "S", "p"))
  names(combin) <- seq(1:length(combin))
  
  combin_df <- invoke(rbind.data.frame,
                      combin)  %>%
    as_tibble() %>%
    rownames_to_column(var = "comb")
  
  plan(multiprocess)
  
 
  exact_probs_dt <-
    future_invoke_map_dfr(rep("compute_exact_probs", length(combin)),
                          combin,
                         # .progress = TRUE,
                          .id = "comb")
  
  exact_probs_dt <- left_join(combin_df,
                              exact_probs_dt,
                              by = "comb")
    return(exact_probs_dt)
}

generate_M <- function(N_max, pr =0.2){
  
  N <- seq(1,N_max)
  
  M_log <- log(pr) + (N-1)*log((1-pr))
  
  M_log <- M_log - max(M_log)
  M <- exp(M_log)
  
  M <- M/ sum(M)

return(M)
}

get_exp_over_M <- function(x, pmf, M){
  z_log <- log(x)+log(M) + log(pmf)
  z<- exp(z_log)
  z<- sum(z)
  return(z)
}

compute_marginals <- function( exact_probs, p_cutoff, M){
  
N_max <- max(exact_probs$N)

M_dt <- tibble( N = seq(1,N_max),
                 M_prop=  M)

  
exact_probs_marg <- exact_probs %>%
      mutate(above_cutoff= (max_p >= (p_cutoff - 1e-6)),
             FAR= (1- max_p)#,
             #PO=1
             ) %>%
  left_join(.,
                               M_dt,
                               by="N") 

marginal_collapsed <- exact_probs_marg %>% 
  summarize(ENR= get_exp_over_M(N, pmf, M_prop)#,
            #ENM= get_exp_over_M(k_chimera, pmf, M_prop),
           # ENP= get_exp_over_M(n_phantoms, pmf, M_prop),
           # ENHR= get_exp_over_M(n_hopreads, pmf, M_prop)
           ) 

ENR <- marginal_collapsed %>%  pull(ENR)
#ENM <- marginal_collapsed %>%  pull(ENM)
#ENP <- marginal_collapsed %>%  pull(ENP)
#ENHR <- marginal_collapsed %>%  pull(ENHR)

exact_probs_marg <- exact_probs_marg %>%
  group_by(above_cutoff) %>% 
  summarize_at(vars(N,FAR, k_chimera, n_phantoms,n_hopreads), # , PO,n_hopreads),
               funs(get_exp_over_M(., pmf, M_prop)))  %>%  
    mutate(FTM=k_chimera-n_phantoms,
          # PHR=n_hopreads/(!!ENHR),
           FTR=N/(!!ENR)
         #  PPM=n_phantoms/(!!ENP),
          # FHR=n_hopreads/(!!ENR),
          # FPM=n_phantoms/(!!ENM)
         ) %>%  
   select(-N, -k_chimera, -n_phantoms)#-n_hopreads

  return(exact_probs_marg)
}


compute_marginals_p <- function(exact_probs,p, p_cutoff, M){
  
 plan(multiprocess)
  exact_probs_dt <-
    future_map_dfr(p_cutoff, 
                    compute_marginals,
                   exact_probs=exact_probs, 
                   M=M,
                          #.progress = TRUE,
                          .id = "p_cutoff") %>%
                    ungroup %>%
                  complete(p_cutoff,
                           above_cutoff,
                           fill=list(p=p))%>% 
    replace(is.na(.), 0) %>% 
  filter(above_cutoff==TRUE) %>%  
   mutate(p_cutoff=as.numeric(p_cutoff))%>%  
   select(-above_cutoff) 
  
    return(exact_probs_dt)
}


compute_marginals_all <-function(S, p, p_cutoff,N_max, M){
  
  exact_probs <- compute_exact_probs_N(S=S,
                                       p=p,
                                       N_max=N_max)
  
  marginals <- compute_marginals_p(exact_probs, 
                                   p=p,
                                   p_cutoff=p_cutoff,
                                   M=M)

  return(marginals)
}

run_all <- function(S_vec, p_vec,M,N_max=20){
   plan(multiprocess)

  p_cutoff <- sort(unique(c(seq(.95, 1,0.005), p_vec, .999)))
  names(p_cutoff) <- p_cutoff
  
  combin <-  cross2( S_vec, p_vec) %>%
    map(setNames, c("S", "p"))
  names(combin) <- seq(1:length(combin))
  
  combin_df <- invoke(rbind.data.frame,
                      combin)  %>%
    as_tibble() %>%
    rownames_to_column(var ="comb")
  marginals_all <-
    future_invoke_map_dfr(rep("compute_marginals_all", length(combin)),
                          combin,
                          .progress = TRUE,
                          p_cutoff=p_cutoff,
                          N_max=N_max,
                          M=M,
                          .id = "comb")
  
  marginals_all <- left_join(combin_df,
                              marginals_all,
                              by = "comb")
    return(marginals_all)
}

```

```{r}
xx <- data$data_outcome %>%
  group_by(r) %>%
  summarize(p_outcome_c=sum(p_outcome_c),
            p_outcome_r=sum(p_outcome_r))
sum(data$data_outcome$p_outcome_r)
ggplot(data$data_outcome) +
  geom_point(aes(p_outcome_r, p_outcome_c))
```

